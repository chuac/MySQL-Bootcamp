GOORM IDE
To start the CLI run:	mysql-ctl cli

CREATE DATABASE <db_name>;

DROP DATABASE <db_name>;

SHOW databases;

Code won't execute until it hits a semi-colon.

USE <db_name>;

SELECT database(); // will tell you which db you're currently using.

A db is just a bunch of tables (in relational dbs).

Convention for table names is to pluralise them. Like products, cats, etc

    CREATE TABLE tablename
      (
        column_name data_type,
        column_name data_type
      );

    CREATE TABLE cats
      (
        name VARCHAR(100),
        age INT
      );

For a simple experiment, these 3 ways to show tables provides the same output:
    SHOW TABLES;
     
    SHOW COLUMNS FROM tablename;
     
    DESC tablename;


DROP TABLE <tablename>;  <-- Be careful with this!


INSERT INTO <tablename>(<column1>, <column2>)
VALUES (<column1DATA>, <column2DATA>);
^ The order matters depending on which column you first declare in the INSERT INTO line, the VALUES data has to match the order.

You can multiple insert! Declare an order of columns you want to insert these rows into with 'INSERT INTO', then have multiple data pairs after VALUEs like:
    INSERT INTO table_name 
                (column_name, column_name) 
    VALUES      (value, value), 
                (value, value), 
                (value, value);

To insert a string (VARCHAR) value that contains quotations, we can either escape the quotes with a backslash like \' or alternate single and double quotes.

When you affect a row, there could be a warning.
SHOW WARNINGS; to see what warnings there were. Strings longer than max length will get truncated to fit.

When we create a table, we can define the columns to be NOT NULL. It will not be permitted to be empty... but you should also provide a default value... otherwise
	INT will default to 0, and VARCHAR will default to empty string ''
We should chain on 'NOT NULL' AND a 'DEFAULT' when creating our table.

CREATE TABLE cats
      (
        name VARCHAR(100) NOT NULL DEFAULT 'no name provided',
        age INT NOT NULL DEFAULT 99
      );


Primary Key: A unique identifier. Declare it when creating a table, can add on optional auto_increment to it! Two ways to define a column as the primary key: see below.
    CREATE TABLE unique_cats2 (
        cat_id INT NOT NULL AUTO_INCREMENT,
        name VARCHAR(100),
        age INT,
        PRIMARY KEY (cat_id)
    );

CREATE TABLE employees (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    last_name VARCHAR(100) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    middle_name VARCHAR(100),
    age INT NOT NULL,
    current_status VARCHAR(50) NOT NULL DEFAULT 'employed'
);


the * after SELECT gives us "all the columns". SELECT <columnName> FROM <tableName>

WHERE helps us add specificity. Searching on a VARCHAR for WHERE is case-insensitive. Like WHERE breed="peRsIaN"; is fine

Aliases: rename the label for it to be printed out to us. SELECT name AS cat_names FROM cats;

UPDATE command: Good rule of thumb: Try SELECTing before you UPDATE! <--------------------
	UPDATE cats SET breed='Shorthair' WHERE breed='Tabby';
	UPDATE cats SET age=14 WHERE name='Misty';
	UPDATE shirts SET shirt_size='XS', color='off white' WHERE color='white';
		^ As you can see above, we can SET multiple columns in one command.

DELETE command: As with UPDATE, a good rule of thumb would be to try SELECTing before DELETE.
	SELECT * FROM cats WHERE name='Egg';
then	DELETE FROM cats WHERE name='Egg';
	
	Primary keys of other data entries don't shift around when you delete something.

	To delete all entries from a table (but not dropping the actual table): 
		DELETE FROM <tableName>;

Running SQL files: Firstly, make sure your SQL CLI is ran from the same directory of where your .sql file is in.
	Secondly, select the proper database you want to use.
	Thirdly, use Source to run your file: 'source query.sql' will run all the SQL code inside query.sql .

	To run an SQL file that's inside another folder (let's say the folder is called 'testing'), run 'source testing/query.sql' .

MySQL String Functions: https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
	You can chain on string functions like: SELECT CONCAT(SUBSTRING(title, 1, 10), '...') AS 'short title' FROM books;

	CONCAT: CONCAT(firstColumn, secondColumn) or CONCAT(author_fname, ' ', author_lname) .
		SELECT CONCAT(author_fname, ' ', author_lname) AS full_name FROM books;
	CONCAT_WS: CONCAT but with a seperator you can define once and it'll be used to seperate all the strings you want to concatenate.

	SUBSTRING: Indexes in MySQL start from 1, not 0.
		SUBSTRING(str FROM pos FOR len)
		SELECT SUBSTRING('Quadratically', 5, 6);  would output 'ratica' .

		SELECT SUBSTRING(title, 1, 10) AS 'short title' FROM books;

	REPLACE: IT IS case sensitive when it searches for occurences of the string/character to replace.
		SELECT REPLACE('HellO World', 'o', '*'); would output 'HellO W*rld' .

		SELECT REPLACE(title, 'e', '3') FROM books;

	REVERSE: Very simple. SELECT REVERSE('Hello'); would output 'olleH' .

	CHAR_LENGTH: Also very simple. Returns the length of the string.
		SELECT author_lname, CHAR_LENGTH(author_lname) AS 'length' FROM books;

	UPPER() and LOWER(): Very simple. SELECT UPPER('Hello World'); would output 'HELLO WORLD' .

Refining our SELECTions:
	DISTINCT: write DISTINCT after SELECT. Gives us just the unique rows of our nominated columns we're SELECTing. 
		Consider, two authors in our DB with different firstname but same lastname, if we select both firstname, lastname .. and put DISTINCT infront, it will show
		both of them. BUT if we just SELECT their lastname (which they both share) .. and put DISTINCT infront, only one entry of their lastname will show.
	
	ORDER BY: sort in ascending order by default (ASC). Can change to descending by adding DESC to the end. Don't have to ORDER BY some column that you're SELECTing!!
		SELECT title FROM books ORDER BY title;
		SELECT title FROM books ORDER BY released_year DESC;
		
		Can use a shortcut like below to choose which of the columns you selected, to ORDER BY:
			SELECT title, author_fname, author_lname FROM books ORDER BY 2; <- that would order by author_fname.

		We can also order by two columns, like if two entries share the same last name, wouldn't we want the first names to be sorted too?
			SELECT title, author_fname, author_lname FROM books ORDER BY author_lname, author_fname; <- sorts by lastname first then firstname
	
	LIMIT: Usually used after an ORDER BY. Specifies how many entries we want to display.
		SELECT title, released_year FROM books ORDER BY released_year DESC LIMIT 5; <- would output the 5 newest books.
		
		We can also set the "starting point" of our LIMIT and how many results we want to show. Could be useful for pagination?:
			SELECT title, released_year FROM books ORDER BY released_year DESC LIMIT 0, 5; <- would output exactly as above. Note the starting index of 0.
			The second argument of "how many results" doesn't have a limit. Can be a gigantic number and it won't error out.
	
	LIKE: pattern matching for better searching. Won't have to search for exact matches! NOT case sensitive. Works great by using wildcards. Escape wildcards with \
		SELECT title, author_fname FROM books WHERE author_fname LIKE '%da%'; would output rows where author_fname includes 'da' in there. Any order.
		SELECT title, author_fname FROM books WHERE author_fname LIKE 'da%'; would only output rows where the author_fname STARTS with 'da'. Doesn't care for trailing.
		
		The % wildcard means "anything".
		THE _ wildcard (underscore) means one character. Putting 4 underscores together means look for something 4 characters long (or 4 digits):
			SELECT title, stock_quantity FROM books WHERE stock_quantity LIKE '____'; four underscores only returns where stock_quantity is 4 digits long.

Aggregate Functions:
	COUNT: literally just counts. Beware of edge cases where there may be duplicate last names but they're actually different people. Run distinct on both name columns!
		SELECT COUNT(*) FROM books; outputs however many rows there are in the books table (19).
		SELECT COUNT(DISTINCT author_fname) FROM books; outputs the count of DISTINCT firstnames.
		SELECT COUNT(title) FROM books WHERE title LIKE '%the%'; outputs how many books there are with 'the' in the title name (6).
	
	GROUP BY: Very useful when used in conjunction with another aggregate function. Creates a "super row" where if you use SELECT COUNT(*) then it'll count how many
			rows got grouped into that super row!
		SELECT author_fname, author_lname, COUNT(*) FROM books GROUP BY author_lname, author_fname; each row of their fname, lname, then a column of their counts
			of books.
		SELECT CONCAT(COUNT(*), ' book(s) released in ', released_year) AS 'year' FROM books GROUP BY released_year; outputs nicer strings in one column like
			"2 book(s) released in 2017".

	MIN and MAX: works as expected.
		SELECT MAX(pages) FROM books; returns the highest number of pages, of any record in the db (634).
		
		This WON'T WORK:
			SELECT MAX(pages), title FROM books; will NOT output the book title with the max pages.
		^ Instead, Use subqueries (slow), ORDER BY and LIMIT, or GROUP BY.
		
		SELECT author_fname, author_lname, Max(pages) FROM books GROUP BY author_lname, author_fname; output the author names and the max page count of their books.

	SUM: straightforward. More useful when used with GROUP BY.
		SELECT author_fname, author_lname, SUM(pages) FROM books GROUP BY author_lname, author_fname; cumulative # of pages each author has written.

	AVG: average to 4 decimal points.
		SELECT released_year, AVG(stock_quantity) FROM books GROUP BY released_year; released year and the average stock quantity of all the books from that year.






1:40
4:20